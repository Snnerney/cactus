---
title: hot100
description: 刷题总结
publishDate: 2024-11-18
draft: true
tags:
  - 算法
ogImage: /social-card.avif
---
### 一、 哈希

#### 1.两数之和

* 暴力解法
* 哈希存储

一些questions：

* 为什么不把数组下标作为key呢？

 在使用哈希表解决“两数之和”问题时，不能直接将数组下标作为键的原因在于：哈希表需要保证键的唯一性，而查询出的 key （两数中的另一个数）对应的的数组下标 并不一定唯一。
 如果数组中存在重复的数字，那么当使用数组下标作为键时，哈希表就会发生冲突。  哈希表的冲突解决机制（例如链地址法或开放地址法）会增加查找时间复杂度，甚至可能导致错误的结果。

例如：
nums = \[2, 7, 11, 15, 7]  target = 9

如果我们试图使用下标作为键：

nums\[0] = 2，键为0
nums\[1] = 7，键为1
nums\[2] = 11，键为2
nums\[3] = 15，键为3
nums\[4] = 7，键为4


当我们查找target - nums\[0] = 7时，我们会找到两个键：1 和 4，对应数组中的两个7。哈希表无法区分这两个7，因为它们都对应了不同的下标。  这将导致算法无法正确地找到正确的下标对(0, 1)。


因此，正确的做法是使用数组中的数值作为键，而将对应的下标作为值存储在哈希表中。这样可以保证键的唯一性，避免哈希冲突，从而高效地找到目标值对应的两个下标。

* 为什么需要先查找map中是否有对应的key，没有再存入map；而不是直接存储在map中？

 由题意你不能两次使用相同的元素 ： 如果直接存入map中，那么就会导致重复，与题意相悖。

#### 2.字母异位词分组

思路：

创建一个HashMap集合用于存储 每个单词排序后去重的唯一key 和 key对应的所有单词。

将数组中的每个string排序`（Arrays.sort(str.toCharArray())）`，str是不会变的，然后将排序后的字符`new String(str.toCharArray())` 作为key，若key存在，则value即为对应的key的value值（List）再添加当前的str；若不存在，则向map中添加这个key和对应的value（创建空list，再add当前的str）。

