---
title: "0820"
description: 这是一篇有意思的文章
publishDate: 2025-08-20T01:11
---
不是，怎么除了主页和状态监控站，其他的网站都访问不了了，aaaaaaa

L站也访问不了

<details>
<summary>面经analysis</summary>

---

### 一、项目与架构设计
#### 1. DDD的优势与劣势
**优势**：
- **分层解耦**：通过领域层、应用层、基础设施层等明确分层，提升代码可维护性
- **技术无关性**：基础设施层可无缝切换ORM/DB（如MyBatis切换为JPA）
- **适配器模式**：通过防腐层（ACL）隔离外部系统变化对核心业务的影响
- **统一语言**：领域模型促进开发与业务人员的高效沟通

**劣势**：
- **对象转换开销**：DTO/DO/VO等多层转换带来性能损耗（可通过MapStruct优化）
- **学习成本高**：需要团队掌握领域建模、事件风暴等方法论
- **过度设计风险**：简单CRUD项目可能得不偿失

#### 2. MQ应用场景与问题解决
**核心价值**：
- 异步解耦（订单创建与通知分离）
- 流量削峰（秒杀场景缓冲）
- 最终一致性（分布式事务补偿）

**典型问题**：
- **消息丢失**：通过生产者确认+持久化+消费者手动ack解决
- **重复消费**：通过幂等性设计（唯一业务ID+状态机）应对
- **顺序消费**：通过单队列单消费者或消息分组保证

#### 3. 大批量导出优化方案
- **分页批处理**：避免OOM（游标分页代替传统分页）
- **异步导出**：通过MQ解耦，提供结果下载链接
- **压缩传输**：使用Snappy压缩结果集
- **列裁剪**：仅返回必要字段
- **缓存复用**：高频相同查询结果缓存

---

### 二、中间件与数据库
#### 1. ElasticSearch核心理解
- **核心特性**：
  - 近实时搜索（refresh_interval控制）
  - 分布式架构（分片与副本机制）
  - 倒排索引+Doc Values组合查询
- **典型场景**：
  - 日志数据聚合分析
  - 商品搜索的多条件过滤
  - 替代MySQL复杂查询（通过binlog同步数据）

#### 2. Redis高可用设计
- **点赞场景设计**：
  - 使用Hash存储用户-视频关系（hincrby计数）
  - 设置过期时间避免冷数据堆积
  - 通过Lua脚本保证原子性操作
- **故障恢复**：
  - 主从集群+哨兵自动切换
  - AOF持久化+定时RDB快照
  - 降级方案：故障时切换本地缓存+异步补偿

#### 3. Lua脚本特性
- **原子性保证**：整个脚本在单次执行中完成
- **减少网络开销**：合并多个操作到单个请求
- **示例应用**：
  ```lua
  local key = KEYS[1]
  local count = redis.call('GET', key)
  if not count then
    redis.call('SET', key, 1)
  else
    redis.call('INCR', key)
  end
  ```

---

### 三、Java核心基础
#### 1. 基础数据类型
| 类型    | 位数  | 字节数 | 默认值  |
|---------|-------|--------|---------|
| byte    | 8     | 1      | 0       |
| short   | 16    | 2      | 0       |
| int     | 32    | 4      | 0       |
| long    | 64    | 8      | 0L      |
| float   | 32    | 4      | 0.0f    |
| double  | 64    | 8      | 0.0d    |
| char    | 16    | 2      | '\u0000'|
| boolean | 1     | -      | false   |

#### 2. String对象创建
`new String("123")` 创建过程：
1. 检查字符串池是否存在"123"
2. 不存在则在堆中创建String对象（指向常量池）
3. new关键字强制创建新堆对象
▶️ 总计产生 **2个对象**（常量池对象+堆对象）

#### 3. 集合扩容机制
**ArrayList**容量10，扩容1.5倍（`int newCapacity = oldCapacity + (oldCapacity >> 1)`）
- 触发条件：`size == elementData.length`

**HashMap**：
- 默认加载因子0.75，扩容2倍
- 树化阈值：链表长度≥8且数组长度≥64
- 2的幂次方原因：通过`(n-1) & hash`快速定位桶位

---

### 四、并发编程深度
#### 1. 单核CPU多线程必要性
- **I/O密集型场景**：当线程阻塞时切换其他线程执行，提升CPU利用率
- **公平调度**：防止单个任务长时间独占CPU
- **编程模型统一**：为多核环境提前设计
- **注意点**：避免过度线程导致频繁上下文切换

#### 2. 锁机制对比
**synchronized**：
- 对象头Mark Word实现（锁标志位占2bit）
- 锁升级过程：无锁→偏向锁→轻量锁→重量锁
- 内存语义：进入monitor时刷新工作内存，退出时同步主存

**ReentrantLock**：
- 基于AQS实现，支持公平/非公平锁
- 条件变量精确控制
- 可中断锁获取

**ThreadLocal**：
- 线程隔离的变量副本
- 内存泄漏风险：需及时remove清理Entry

#### 3. JMM与volatile
- **JMM三大特性**：
  - 原子性：synchronized保证
  - 可见性：volatile强制主存读写
  - 有序性：内存屏障禁止指令重排
- **volatile实现**：
  - 写操作后插入StoreLoad屏障
  - 读操作前插入LoadLoad屏障

---

### 五、Spring框架核心
#### 1. BeanFactory vs FactoryBean
| 特性              | BeanFactory                    | FactoryBean                  |
|-------------------|--------------------------------|------------------------------|
| 定位              | IOC容器基础接口                | 特殊Bean创建工厂             |
| 获取对象          | getBean()直接返回目标对象      | getBean()返回FactoryBean产品 |
| 典型实现          | DefaultListableBeanFactory     | SqlSessionFactoryBean        |

#### 2. SpringMVC流程
1. DispatcherServlet接收请求
2. 通过HandlerMapping找到对应Controller
3. HandlerAdapter执行处理方法
4. 参数解析（@RequestBody等）
5. 方法返回ModelAndView
6. ViewResolver解析视图
7. 渲染响应返回

#### 3. AOP实现原理
- **代理模式选择**：
  - JDK动态代理（接口级代理）
  - CGLIB代理（类级代理）
- **织入时机**：
  - 编译时织入（AspectJ）
  - 运行时织入（Spring AOP）
- **核心组件**：
  - Pointcut：切入点定义
  - Advice：增强逻辑
  - Advisor：整合Pointcut和Advice

---

### 高频考点总结
1. **单核多线程价值**：重点理解I/O等待时的CPU利用率优化
2. **synchronized局限性**：不能解决原子性外的可见性和有序性问题
3. **ES核心价值**：区别于传统DB的搜索优化能力
4. **DDD分层本质**：业务复杂度与技术实现解耦
5. **Redis高可用**：多级故障应对方案设计

建议针对薄弱环节重点突破，如通过JOL工具分析对象头结构，使用Arthas观察线程状态变化等实践加深理解。
</details>
